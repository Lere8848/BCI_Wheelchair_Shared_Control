# fusion_node.py
import rclpy
from rclpy.node import Node
from std_msgs.msg import Int8, Int8MultiArray, Bool
from geometry_msgs.msg import Twist
import time
import threading
from rclpy.duration import Duration

# LSL import
try:
    from pylsl import StreamInfo, StreamOutlet
    LSL_AVAILABLE = True
except ImportError:
    LSL_AVAILABLE = False

class FusionNode(Node):
    def __init__(self):
        super().__init__('fusion_node')
        self.cmd_pub = self.create_publisher(Twist, '/cmd_vel', 10)

        self.user_cmd_sub = self.create_subscription(Int8, '/user_cmd', self.user_cmd_callback, 10)
        self.path_opt_sub = self.create_subscription(Int8MultiArray, '/path_options', self.path_callback, 10)
        
        # Subscribe to Ground Truth input
        self.gt_input_sub = self.create_subscription(Int8, '/gt_input', self.gt_input_callback, 10)
        
        # Subscribe to potential field algorithmpath commands (generated on demand)
        self.auto_cmd_sub = self.create_subscription(Twist, '/auto_cmd_vel', self.auto_cmd_callback, 10)
        
        # Subscribe to multipath detection signal
        self.multipath_sub = self.create_subscription(
            Int8MultiArray, 
            '/multipath_detected', 
            self.multipath_callback, 
            10
        )

        # Subscribe to path blocked signal
        self.path_blocked_sub = self.create_subscription(Bool, '/path_blocked', self.path_blocked_callback, 10)

        self.danger = False
        self.create_subscription(Bool, '/danger_stop', self.danger_callback, 10)

        self.path_options = [1, 1, 1]  # path feasibility [left, forward, right]
        self.path_blocked = False      # whether overall path is blocked
        self.auto_cmd = Twist()        # motion command generated by potential field algorithm
        
        # multipath detectionstatus
        self.multipath_detected = False
        self.multipath_status = [False, False, False]  # [left, forward, right] which directions have paths
        
        # control status: default idle, waiting for user trigger
        self.state = "IDLE"  # IDLE, EXECUTING, WAITING_FOR_USER
        self.execution_start_time = None
        self.execution_duration = 3.0  # execution duration per time (seconds)
        
        # user intentstatus
        self.pending_user_direction = None  # pending user direction intent
        self.last_user_command_time = None
        
        # Ground Truth status control
        self.waiting_for_groundtruth = False  # whether waiting for true intent input
        self.groundtruth_received = False     # whether true intent has been received
        
        # LSL output stream setup - send wheelchair motion status to BCI
        self.lsl_outlet = None
        self.wheelchair_moving = False  # wheelchair motion status tracking
        if LSL_AVAILABLE:
            try:
                # Create LSL stream: 1 channel [Motion_Flag] - continuous transmission
                info = StreamInfo('Wheelchair_Motion', 'Motion_Flag', 1, 10, 'float32', 'control_fusion_node')
                self.lsl_outlet = StreamOutlet(info)
                self.get_logger().info('LSL outlet created for wheelchair motion status transmission to BCI')
            except Exception as e:
                self.get_logger().warn(f'Failed to create LSL outlet: {str(e)}')
        else:
            self.get_logger().warn('LSL not available - wheelchair motion status will not be sent to BCI')
        
        self.timer = self.create_timer(0.1, self.timer_callback)

    def path_callback(self, msg):
        if len(msg.data) == 3:
            self.path_options = msg.data

    def multipath_callback(self, msg):
        """receive multipath detection results"""
        if len(msg.data) == 3:
            self.multipath_status = [bool(x) for x in msg.data]
            self.multipath_detected = sum(self.multipath_status) >= 2
            
            if self.multipath_detected:
                self.get_logger().info(f'Multiple paths detected: Left={self.multipath_status[0]}, Front={self.multipath_status[1]}, Right={self.multipath_status[2]}')
                # in multipath situation, if no pending user command, prompt waiting
                if self.pending_user_direction is None and self.state == "IDLE":
                    self.get_logger().warn('Multiple paths available, waiting for user direction input...')

    def danger_callback(self, msg):
        """danger detection callback - immediate stop"""
        self.danger = msg.data
        if self.danger:
            self.get_logger().warn('Danger detected! Emergency stop!')
            # immediate stopwheelchair
            stop_cmd = Twist()
            self.cmd_pub.publish(stop_cmd)
    
    def auto_cmd_callback(self, msg):
        """receivemotion command generated by potential field algorithm"""
        self.auto_cmd = msg
        
    def path_blocked_callback(self, msg):
        """updatepath blockedstatus"""
        self.path_blocked = msg.data

    def gt_input_callback(self, msg):
        """Ground Truth input callback"""
        if self.waiting_for_groundtruth:
            direction_names = ["Left", "Forward", "Right"]
            self.get_logger().info(f'Ground truth received: {direction_names[msg.data]}')
            self.groundtruth_received = True
            self.waiting_for_groundtruth = False

    def send_motion_status(self, is_moving):
        """send wheelchair motion status to BCI system"""
        if self.lsl_outlet and LSL_AVAILABLE:
            try:
                # Single channel: 1.0 for moving, 0.0 for stopped
                motion_flag = 1.0 if is_moving else 0.0
                self.lsl_outlet.push_sample([motion_flag])
                
                # log only when status changes to avoid spam
                if self.wheelchair_moving != is_moving:
                    self.get_logger().info(f'Wheelchair motion status changed: Moving={is_moving}')
                    self.wheelchair_moving = is_moving
            except Exception as e:
                self.get_logger().warn(f'Failed to send motion status via LSL: {str(e)}')

    def timer_callback(self):
        """main control loop - user-triggered potential field execution"""
        current_time = self.get_clock().now()
        
        # Check danger status
        if self.danger:
            # immediate stop under danger status and return to idle status
            self.state = "IDLE"
            self.pending_user_direction = None
            stop_cmd = Twist()
            self.cmd_pub.publish(stop_cmd)
            self.send_motion_status(False)  # Send stop status
            return
        
        # state machine logic
        if self.state == "IDLE":
            # idle status：wheelchair idle, waiting for user trigger
            if self.pending_user_direction is not None:
                # Check whether waiting for ground truth
                if self.waiting_for_groundtruth:
                    # Wait for ground truth input, keep idle
                    stop_cmd = Twist()
                    self.cmd_pub.publish(stop_cmd)
                    self.send_motion_status(False)  # Send stop status
                    return
                
                # Ground truth received or no need to wait, check path feasibility
                direction = self.pending_user_direction
                if self.path_options[direction] == 1:
                    self.get_logger().info(f'Starting execution for user direction: {["Left", "Right", "Forward"][direction]}')
                    self.state = "EXECUTING"
                    self.execution_start_time = current_time
                    self.send_motion_status(True)  # Send moving status
                    # clear pending intent
                    self.pending_user_direction = None
                else:
                    # user selected direction is blocked
                    self.get_logger().warn(f'User selected direction {["Left", "Right", "Forward"][direction]} is blocked, staying idle')
                    self.pending_user_direction = None
                    stop_cmd = Twist()
                    self.cmd_pub.publish(stop_cmd)
                    self.send_motion_status(False)  # Send stop status
            else:
                # no pending intent, keep idle
                stop_cmd = Twist()
                self.cmd_pub.publish(stop_cmd)
                self.send_motion_status(False)  # Send stop status
        
        elif self.state == "EXECUTING":
            # execution status：execute user selected direction according to potential field algorithm
            if self.execution_start_time is not None:
                elapsed = current_time - self.execution_start_time
                
                if elapsed > Duration(seconds=self.execution_duration):
                    # execution time reached, return to idle status
                    self.get_logger().info('Execution completed, returning to idle state')
                    self.state = "IDLE"
                    self.execution_start_time = None
                    stop_cmd = Twist()
                    self.cmd_pub.publish(stop_cmd)
                    self.send_motion_status(False)  # Send stop status
                    return

            # keep potential field algorithm output
            if not (self.auto_cmd.linear.x == 0.0 and self.auto_cmd.angular.z == 0.0):
                self.get_logger().debug(f'Executing potential field command: linear={self.auto_cmd.linear.x:.2f}, angular={self.auto_cmd.angular.z:.2f}')
                self.cmd_pub.publish(self.auto_cmd)
                self.send_motion_status(True)  # Send moving status
            else:
                # potential field algorithm output is zero, may have reached target or encountered obstacle, end execution
                self.get_logger().info('Potential field output is zero, ending execution early')
                self.state = "IDLE"
                self.execution_start_time = None
                stop_cmd = Twist()
                self.cmd_pub.publish(stop_cmd)
                self.send_motion_status(False)  # Send stop status
    
    def user_cmd_callback(self, msg):
        """user command callback - trigger potential field algorithm to execute user selected direction"""
        direction = msg.data  # 0=left, 1=right, 2=forward

        if direction < 0 or direction > 2:
            self.get_logger().warn(f'Invalid direction: {direction}')
            return

        direction_names = ["Left", "Right", "Forward"]
        self.get_logger().info(f'User command received: {direction_names[direction]}')
        
        # if currently executing, terminate current execution and prepare new execution
        if self.state == "EXECUTING":
            self.get_logger().info('Interrupting current execution for new user command')
            self.state = "IDLE"
            self.execution_start_time = None
            self.send_motion_status(False)  # Send stop status
        
        # Wait for Ground Truth input
        self.get_logger().info('Waiting for ground truth input...')
        self.waiting_for_groundtruth = True
        self.groundtruth_received = False
        self.pending_user_direction = direction
        self.last_user_command_time = self.get_clock().now()


def main(args=None):
    rclpy.init(args=args)
    node = FusionNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()
